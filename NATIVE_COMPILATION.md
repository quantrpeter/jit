# Native Mach-O Compilation

This JIT compiler now supports compiling Java bytecode all the way down to native machine code in Mach-O executable format for macOS!

## Overview

The native compilation pipeline:
1. **Java Bytecode** → Analyzed by `BytecodeAnalyzer`
2. **Machine Code** → Generated by `MachineCodeGenerator` (x86-64 or ARM64)
3. **Mach-O Binary** → Written by `MachOWriter` as executable file

## Architecture Support

✅ **ARM64** (Apple Silicon - M1/M2/M3)  
✅ **x86-64** (Intel Macs)

The compiler automatically detects your system architecture and generates appropriate machine code.

## Features

### Machine Code Generation
- Converts Java bytecode instructions to native assembly
- Supports arithmetic operations (add, sub, mul, div)
- Handles local variables and constants
- Generates proper function prologues/epilogues
- Architecture-specific code generation

### Mach-O File Format
- Proper Mach-O headers for 64-bit executables
- `__TEXT` segment with executable permissions
- Correct section alignment and padding
- Entry point configuration
- Automatically sets executable permissions

## Usage

###  Basic Example

```java
import com.jitcompiler.NativeCompiler;
import java.nio.file.Path;

// Create native compiler
Native Compiler compiler = new NativeCompiler();

// Compile a Java method to native executable
Path executable = compiler.compileToNative(
    "com.jitcompiler.samples.Calculator",
    "calculator"  // output filename
);

// Run it!
// ./calculator
```

### API Methods

#### 1. `compileExpression(String expression, String outputFile)`
Compiles a simple expression to native code.

```java
Path exe = compiler.compileExpression("42", "simple_expr");
// Creates: ./simple_expr (returns 42)
```

#### 2. `compileToNative(String className, String outputFile)`
Compiles a single method from a class to native code.

```java
Path exe = compiler.compileToNative(
    "com.jitcompiler.samples.Calculator",
    "calculator_add"
);
// Compiles the add() method
```

#### 3. `compileClassToNative(String className, String outputFile)`
Compiles all methods from a class into one executable.

```java
Path exe = compiler.compileClassToNative(
    "com.jitcompiler.samples.Calculator",
    "calculator_full"
);
// Includes all Calculator methods
```

## Running from Tests

The native compiler is thoroughly tested:

```bash
mvn test -Dtest=NativeCompilerTest
```

Tests include:
- ✅ Expression compilation
- ✅ Method compilation
- ✅ Full class compilation
- ✅ Mach-O file generation
- ✅ Executable permissions
- ✅ Architecture detection

## Generated Executables

When you run the native compiler, it creates real Mach-O executables:

```bash
$ file simple_expr
simple_expr: Mach-O 64-bit executable arm64

$ ./simple_expr
# Executes native ARM64 code!
```

## How It Works

### 1. Bytecode Analysis
```java
BytecodeAnalyzer analyzer = new BytecodeAnalyzer();
analyzer.analyze("com.jitcompiler.samples.Calculator");
ClassNode classNode = analyzer.getClassNode();
```

### 2. Machine Code Generation
```java
MachineCodeGenerator generator = new MachineCodeGenerator();
byte[] machineCode = generator.generateMethodCode(method);
```

Example bytecode → machine code translation:

**Java Bytecode:**
```
ICONST_2    // Push 2
ICONST_3    // Push 3
IADD        // Add
IRETURN     // Return
```

**ARM64 Machine Code:**
```assembly
mov w0, #2
mov w1, #3
add w0, w0, w1
ret
```

**x86-64 Machine Code:**
```assembly
mov eax, 2
mov ebx, 3
add eax, ebx
ret
```

### 3. Mach-O File Writing
```java
MachOWriter writer = new MachOWriter("ARM64");
writer.writeExecutable(outputPath, machineCode, entryPoint);
```

Creates proper Mach-O structure:
- Mach header (magic, CPU type, load commands)
- Load commands (segments, entry point)
- Segment (__TEXT with __text section)
- Machine code data
- Proper alignment and padding

## Architecture Details

### ARM64 Code Generation

**Function Prologue:**
```assembly
stp x29, x30, [sp, #-16]!  // Save frame pointer and link register
mov x29, sp                 // Set frame pointer
sub sp, sp, #64             // Allocate stack space
```

**Arithmetic Operations:**
```assembly
add w0, w1, w2   // Add: w0 = w1 + w2
sub w0, w1, w2   // Subtract: w0 = w1 - w2
mul w0, w1, w2   // Multiply: w0 = w1 * w2
sdiv w0, w1, w2  // Divide: w0 = w1 / w2
```

**Function Epilogue:**
```assembly
add sp, sp, #64             // Restore stack
ldp x29, x30, [sp], #16     // Restore registers
ret                         // Return
```

### x86-64 Code Generation

**Function Prologue:**
```assembly
push rbp          // Save base pointer
mov rbp, rsp      // Set base pointer
sub rsp, 64       // Allocate stack space
```

**Arithmetic Operations:**
```assembly
add eax, ebx      // Add
sub eax, ebx      // Subtract
imul eax, ebx     // Multiply
idiv ebx          // Divide
```

**Function Epilogue:**
```assembly
mov rsp, rbp      // Restore stack
pop rbp           // Restore base pointer
ret               // Return
```

## Mach-O File Structure

```
┌─────────────────────┐
│   Mach-O Header     │  (32 bytes)
│  - Magic: 0xfeedfacf│
│  - CPU Type         │
│  - File Type        │
├─────────────────────┤
│  Load Commands      │
│  - LC_SEGMENT_64    │  (__TEXT segment)
│  - LC_MAIN          │  (Entry point)
├─────────────────────┤
│   Padding to 4KB    │
├─────────────────────┤
│   Machine Code      │  (Your compiled code)
│   (.text section)   │
└─────────────────────┘
```

## Supported Bytecode Instructions

Currently supported Java bytecode instructions:

| Bytecode | Description | Machine Code |
|----------|-------------|--------------|
| `ICONST_M1` to `ICONST_5` | Push constant | `mov reg, #value` |
| `BIPUSH` | Push byte | `mov reg, #value` |
| `LDC` | Load constant | `mov reg, #value` |
| `IADD` | Integer add | `add`/`iadd` |
| `ISUB` | Integer subtract | `sub`/`isub` |
| `IMUL` | Integer multiply | `mul`/`imul` |
| `IDIV` | Integer divide | `sdiv`/`idiv` |
| `ILOAD` | Load local variable | Load from stack |
| `ISTORE` | Store local variable | Store to stack |
| `IRETURN` | Return integer | `ret` with value |
| `RETURN` | Return void | `ret` |

## Limitations

This is a demonstration JIT compiler. Production limitations:

- **No dynamic linking** - Standalone executables only
- **Limited instruction set** - Basic arithmetic and control flow
- **No garbage collection** - Primitive types only
- **No exception handling** - Assumes successful execution
- **No optimization passes** - Direct bytecode translation
- **Simplified calling convention** - May not match system ABI exactly

## Example Output

```bash
$ mvn test -Dtest=NativeCompilerTest#testCompileExpression

Machine Code Generator initialized for: ARM64

╔════════════════════════════════════════════════╗
║   Native Mach-O Compilation Started            ║
╚════════════════════════════════════════════════╝
Class: com.jitcompiler.samples.Calculator
Target: calculator
Architecture: ARM64

=== Analyzing Bytecode ===
Target method: add(II)I
  Instructions: 7
  Arithmetic ops: 1

=== Generating Native Code ===
  Generating native code for method: add
  Generated 48 bytes of native code

=== Creating Mach-O Executable ===
Writing Mach-O executable: calculator
  Architecture: ARM64
  Code size: 48 bytes
  Output size: 8192 bytes
  Entry point: 0x100001000

✓ Mach-O executable written successfully

╔════════════════════════════════════════════════╗
║   Native Compilation Completed                 ║
╚════════════════════════════════════════════════╝
Executable: /path/to/calculator

You can now run:
  ./calculator
```

## Verifying Generated Executables

```bash
# Check file type
$ file calculator
calculator: Mach-O 64-bit executable arm64

# Check if executable
$ ls -l calculator
-rwxr-xr-x  1 user  staff  8192 Nov 19 18:57 calculator

# Disassemble (requires otool or similar)
$ otool -tv calculator
calculator:
(__TEXT,__text) section
0000000100001000    stp    x29, x30, [sp, #-0x10]!
0000000100001004    mov    x29, sp
...
```

## Future Enhancements

Potential improvements:
- [ ] Complete instruction set support
- [ ] Register allocation optimization
- [ ] Peephole optimizations
- [ ] System call support
- [ ] Dynamic linking
- [ ] Full System V AMD64 ABI compliance
- [ ] Exception handling
- [ ] Debug symbol generation (DWARF)
- [ ] Support for other platforms (Linux ELF, Windows PE)

## Resources

- [Mach-O File Format](https://github.com/aidansteele/osx-abi-macho-file-format-reference)
- [ARM64 Instruction Set](https://developer.arm.com/documentation/ddi0596/latest/)
- [x86-64 Instruction Reference](https://www.felixcloutier.com/x86/)
- [System V AMD64 ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf)

## License

Educational and demonstration purposes.

